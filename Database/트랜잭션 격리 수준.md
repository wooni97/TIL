


<aside>
💡  트랜잭션(Transaction 이하 트랜잭션)이란, 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위를 뜻한다.

</aside>

### 트랜잭션 격리 수준이란?

동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것이다.

즉, 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.

격리 수준은 4개로 나뉜다.

- READ UNCOMMITED
- READ COMMITED
- REPEATABLE READ
- SERIALIZABLE

아래로 내려갈수록 트랜잭션간 고립 정도가 높아지고, 성능이 떨어진다.

```
참고로 아래의 예제들은 모두 자동 커밋(AUTO COMMIT)이 false인 상태에서만 발생한다. ?? ? ? ? 
```

### READ UNCOMMITED

어떤 트랜잭션의 변경 내용이 COMMIT, ROLLBACK과 상관없이 다른 트랙잭션에 보여진다.

어떤 트랜잭션의 작업이 완료되지 않았는데도, 다른 트랜잭션에서 볼 수 있는 Dirty Read가 발생할 수 있다.

예시)

1. A 트랜잭션에서 10번 사원의 나이를 27살에서 28살로 변경
2. 커밋 하지 않음
3. B 트랜잭션에서 10번 사원의 나이를 조회함 → 28살이 조회됨 (Dirty Read)
4. A 트랜잭션에서 문제가 발생해 ROLLBACK
5. B 트랜잭션은 10번 사원이 여전히 28살이라고 생각하고 로직을 수행한다

READ UNCOMMITTED는 RDBMS 표준에서 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다. 따라서 MySQL을 사용한다면 최소한 READ COMMITTED 이상의 격리 수준을 사용해야 한다.

### READ COMMITED

어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있다.

> **Non-Repeatable Read(반복 읽기 불가능)**
>

반복 읽기를 수행하면 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라질 수 있다. 이러한 데이터 부정합 문제를 Non-Repeatable Read라고 한다.

예시)

1. 사용자 A가 27살인 10번 사원의 나이를 조회한다.
2. 사용자 B가 10번 사원의 나이를 28살로 변경하고 커밋한다.
3. 사용자가 A가 10번 사원의 나이를 다시 조회하면 28살이 조회된다.

하나의 트랜잭션에서 똑같은 SELECT를 수행했을 경우 항상 같은 결과를 반환해야 한다는 REPEATABLE READ 정합성에 어긋나는 것이다.

하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 생길 수 있다. 예를 들어 어떤 트랜잭션에서 오늘 입금된 총 합을 계산하고 있는데, 다른 트랜잭션에서 계속해서 입금 내역을 커밋하는 상호아이라고 하자. 그러면 같은 트랜잭션일지라도 조회할 때마다 입금된 내역이 달라지므로 문제가 생길 수 있다.

### REPEATABLE READ

일반적인 RDBMS는 변경 전의 레코드를 언두 공간에 백업해둔다. 변경 전/후 데이터가 모두 존재하므로, 동일한 레코드에 대해 여러 버전의 데이터가 존재한다고 하여 이를 MVCC라고 부른다.

각각의 트랜잭션은 순차 증가는 고유한 트랜잭션 번호가 존재하며, 백업 레코드에서는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장한다.

REPEATABLE READ는 트랜잭션이 시작되기 전, 즉자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된것만 보게 되는 것이다.

> **새로운 레코드가 추가되는 경우에 부정합 : 유령 읽기 (Phantom Read)**
>

SELECT로 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데, 이를 유령 읽기라고 한다.

하지만 MVCC 덕분에 일반적인 조회에서 유령 읽기는 발생하지 않는다. 왜냐하면 자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시하면 되기 때문이다.

그렇다면 유령 읽기는 언제 발생하는 것일까? 바로 **잠금이 사용되는 경우**이다.

읽기 잠금이나 쓰기 잠금을 사용하여 레코드를 조회하는 경우에는 언두 영역의 데이터가 아니라 테이블에서 데이터를 조회하기 때문에 유령 읽기가 발생한다.

<aside>
💡 MySQL에서는 갭 락이 존재하기 때문에 위의 상황에서 문제가 발생하지 않는다. (이는 다음에 더 자세히 알아보기)

</aside>

DELETE에 대해서는 적용되지 않는데, 이것에 대한 이유도 다음에 살펴보겠다.

### SERIALIZABLE

가자 엄격한 격리 수준으로, 트랜잭션을 순차적으로 진행시킨다.

여러 트랜잭션이 동일한 레코드에 동시에 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않는다. 하지만 트랜잭션이 순차적을 처리되어야 하므로 동시 처리 성능이 매우 떨어진다.