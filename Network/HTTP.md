## HTTP

### HTTP/1.0

하나의 연결당 한개의 요청만 처리하도록 설계되었다. 서버로부터 파일을 가져올때마다 3-way handshake를 계속해서 열어야 했기 때문에 RTT가 증가하는 단점이 있다.

- RTT (Round Trip Time) : 네트워크 패킷이 송신 측에서 수신 측으로 전달되고, 다시 송신 측으로 돌아오기까지 걸리는 시간.

**RTT 증가를 해결하기 위한 방법**

1. 이미지 스플리팅
   - 이미지를 여러개의 작은 조각들로 나누어 효율적으로 전송하는 방식.
   - 필요한 부분만 전송하여 불필요한 RTT 감소
2. 코드 압축
   - 코드를 압축해서 개행문자, 빈칸 등을 없애 코드의 크기를 최소화 하는 방식.
3. 이미지 Base 64 인코딩
   - 이미지 파일을 64비트로 이루어진 문자열로 인코딩 하는 방식.
   - 일반적으로 웹 페이지에서 이미지를 사용하려면 <img> 태그나 css 파일의 이미지 url을 참조해야한다. 이 방식은 브라우저가 html 파싱 후 별도의 요청을 통해 서버에서 이미지를 가지고 오는 것이다. 이미지 Base 64 인코딩을 사용하면 이미지를 외부 url에 직접 요청하지 않고, html 내부에 포함하는 것이다.
   - 크기가 약 33% 커짐

### HTTP/1.1

매번 TCP 연결을 하는 것이 아니라, TCP 초기화를 한 후 keep-alive 옵션으로 여러 개의 파일을 송수신할 수 있다. HTTP/1.0에서도 keep-alive가 있었지만 표준화가 되어있지 않고 HTTP/1.1표준화 되어 기본 옵션으로 설정.

문서 안에 포함된 다수의 리소스(이미지, 동영상, css 파일, js 파일 등)를 처리하려면 요청할 리소스 개수에 비례해서 대기 시간이 길어지는 단점이 있다.

**HTTP/1.1 단점**

- **HOL Blocking(Head Of Line Blocking)**

  네트워크에서 데이터 전송 시 앞선 데이터가 지연되면서 뒤따르는 데이터의 처리가 막혀 발생하는 성능 저하 현상.

- **무거운 헤더 구조**

***HOL Blocking 자세히 살펴보기**

1. 파이프라이닝이 없는 경우
- HTTP/1.1에서는 기본적으로 직렬 요청-응답 모델을 사용한다.
- 요청은 한 번에 하나씩 처리되고, 서버 응답이 완료될 때까지 다음 요청은 대기 상태애 놓여진다.

1. 파이프라이닝이 있는경우
- 파이프라이닝은 요청을 병렬로 보내더라도 응답 순서를 보장해야 하기 때문에, 앞선 요청이 지연되면 뒤따르는 요청도 차단된다.

(파이프라이닝이란 요청에 대한 응답을 기다리지 않고도 단일 TCP 연결을 통해 여러 HTTP 요청을 보내는 것이다.)

---

### HTTP/2

HTTP/1.X보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있으며 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜이다.

**멀티플렉싱**

- 여러 개의 스트림을 사용하여 송수신하는 것.

HTTP/2.0은 기존에 text로 보내던 메시지를 binary화 하여 header frame, body frame이라는 데이터 단위를 만들었다.


HTTP/2.0은 여러개의 스트림을 사용하여 데이터를 송수신하였는데, 스트림은 고유한 스트림 ID를 가진다. 그리고 각 frame을 구분하고자 Stream ID를 frame에 붙이게 된다. HTTP/2는 같은 스트림 ID를 공유하는 프레임들을 하나의 스트림으로 묶어 처리한다.


HTTP/2는 멀티플렉싱을 지원하면서, 여러 스트림의 header, data 프레임이 혼합되어 전송될 수 있다. 그러나, 스트림ID를 공유하는 각 스트림 내에서는 header frame, data frame의 순서를 유지해야한다.

그림처럼 요청3의 header frame이 요청 2의 header frame보다 먼저 오는 것은 가능하다. 각 스트림별로 header, data 순서만 지키면된다.

**멀티플렉싱과 HOL Blocking**

HTTP/2는 하나의 TCP 연결에서 여러 스트림을 동시에 처리하는 멀티플렉싱을 도입하여, **HTTP/1.1에서 발생하던 HOL Blocking을 애플리케이션 계층에서는 해결**할 수 있었다.

HTTP/1.1은 요청에 대한 응답의 순서가 지켜져야 하는데, HTTP/2의 스트림은 독립적으로 작동하며 특정 스트림이 지연되더라도 다른 스트림이 영향을 받지 않는 구조이기 때문이다.

그러나, HTTP/2는 TCP를 기반으로 동작한다. 따라서, **TCP에서 발생하는 HOL Blocking은 여전히 해결하지 못하는 한계가 있다.**

TCP는 신뢰성을 보장하기 위해 데이터를 순서대로 전송해야 하며, 패킷 손실이 발생하면 해당 패킷을 재전송받기 전까지 다음 데이터를 처리하지 않는다. 따라서, 그 연결을 사용하는 모든 스트림이 영향을 받는다.

**헤더 압축**

HTTP/1.x에는 헤더의 크기가 큰 문제가 있었다. 이를 HTTP/2에서는 헤더 압축을 써서 해결하였다.

**서버 푸시**

HTTP/2는 클라이언트의 요청 없이 서버가 바로 리소스를 푸시할 수 있다. html에는 css나 js 파일이 포함되기 마련인데 html을 읽으면서 그 안에 들어 있는 파일들을 서버에서 푸시하여 클라이언트에게 먼저 줄 수 있다.

---

### HTTP/3

TCP 위에서 돌아가는 HTTP/2와는 달리, HTTP/3는 **QUIC(Quick UDP Internet Connections)**이라는 계층 위에서 돌아가며 UDP 기반으로 돌아간다. HOL Blocking 문제를 해결하는데 중점을 두고 설계되었다.


**HOL Blocking 문제 해결**

UDP에 기반한 QUIC 프로토콜을 사용하게 되면서 각 스트림은 독립적이게 되었다. 따라서, 하나의 스트림에서 패킷 손실이 발생하더라도 다른 스트림에 영향을 주지 않는다. 패킷 손실은 해당 스트림에만 영향을 미치며 나머지 스트림은 중단 없이 계속 데이터를 전송할 수 있게 된다.

**0-RTT Handshake**


0-RTT(Zero Round-Trip Time) Handshake는 연결 과정에서 데이터 전송을 지연없이 즉시 시작할 수 있도록 설계된 기술이다. QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할때 번거로운 3-way handshake가 불필요하다.

**기존 TLS Handshake**

1. TLS 1.2 및 TCP
- 초기 연결에는 3-way handshake와 TLS 설정이 필요하며, 데이터 전송 전에 여러 RTT가 소모된다.
1. TLS 1.3
- Handshake가 간소화되었지만, 여전히 첫 연결 시 1-RTT가 필요하다.

**QUIC와 0-RTT**

0-RTT 기능은 이전 연결에서 얻은 정보를 재활용하여 핸드셰이크를 건너뛰도록 허용한다.

QUIC은 UDP 기반으로 3-way handshake가 필요 없고, TLS 1.3과 통합되어 0-RTT가 더 효과적으로 구현된다. 이전 연결에서 세션 키 또는 PSK를 사용하여 즉시 데이터 전송을 시작할 수 있다.